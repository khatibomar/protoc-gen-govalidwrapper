package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/khatibomar/protoc-gen-govalidwrapper/govalid"
)

func generate(gen *protogen.Plugin, file *protogen.File) error {
	// Skip generating code for govalid.proto files
	if strings.Contains(file.Desc.Path(), "govalid.proto") {
		return nil
	}

	// Use source-relative path instead of Go import path
	protoPath := file.Desc.Path()
	// Remove .proto extension and add _govalid.pb.go
	baseFilename := strings.TrimSuffix(protoPath, ".proto")
	filename := baseFilename + "_govalid.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-govalidwrapper. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()

	// Check if govalid is installed
	if err := checkGovalidInstalled(); err != nil {
		return err
	}

	// Pass 1: Generate wrapper structs only
	for _, message := range file.Messages {
		generateWrapperStruct(g, message)
	}

	// Pass 2: Write file, run govalid, then generate validation methods
	if err := generateValidationMethods(file, g, gen, filename); err != nil {
		return err
	}

	return nil
}

func generateWrapperStruct(g *protogen.GeneratedFile, msg *protogen.Message) {
	wrapperName := lowerFirst(msg.GoIdent.GoName) + "Wrapper"

	// Generate wrapper struct
	g.P("type ", wrapperName, " struct {")

	// For each field, generate govalid comments + field
	for _, field := range msg.Fields {
		// Get govalid options from field
		if opts := getGovalidOptions(field); len(opts) > 0 {
			// Generate one marker per line for each rule
			for _, rule := range opts {
				g.P("// +govalid:", rule)
			}
		}
		g.P(field.GoName, " ", fieldGoType(field))
	}
	g.P("}")
	g.P()
}

func generateValidationMethods(file *protogen.File, g *protogen.GeneratedFile, gen *protogen.Plugin, filename string) error {
	// Create a temporary directory for govalid processing
	tempDir, err := os.MkdirTemp("", "govalidwrapper-*")
	if err != nil {
		return fmt.Errorf("failed to create temp directory: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Write the file with wrapper structs to temp directory
	content, err := g.Content()
	if err != nil {
		return fmt.Errorf("failed to get file content: %v", err)
	}

	tempFile := filepath.Join(tempDir, filepath.Base(filename))
	if err := os.WriteFile(tempFile, content, 0644); err != nil {
		return fmt.Errorf("failed to write temp file: %v", err)
	}

	// Create a minimal go.mod for govalid
	goMod := `module temp

go 1.21

require (
	github.com/sivchari/govalid v1.0.0
)
`
	if err := os.WriteFile(filepath.Join(tempDir, "go.mod"), []byte(goMod), 0644); err != nil {
		return fmt.Errorf("failed to write go.mod: %v", err)
	}

	// Run govalid in temp directory
	if err := runGovalid(tempDir); err != nil {
		return fmt.Errorf("govalid execution failed: %v", err)
	}

	// Copy govalid-generated validator files as protogen.GeneratedFile
	tempFiles, err := os.ReadDir(tempDir)
	if err != nil {
		return fmt.Errorf("failed to read temp directory: %v", err)
	}

	for _, tempFileInfo := range tempFiles {
		if tempFileInfo.IsDir() {
			continue
		}

		// Only process validator files, skip go.mod and the main file
		if tempFileInfo.Name() == "go.mod" || tempFileInfo.Name() == filepath.Base(filename) {
			continue
		}

		// Read the govalid-generated file
		src := filepath.Join(tempDir, tempFileInfo.Name())
		content, err := os.ReadFile(src)
		if err != nil {
			return fmt.Errorf("failed to read govalid file %s: %v", tempFileInfo.Name(), err)
		}

		// Create a new protogen.GeneratedFile for this validator file
		// Place it in the same directory as the main _govalid.pb.go file
		validatorFilename := filepath.Join(filepath.Dir(filename), tempFileInfo.Name())
		validatorFile := gen.NewGeneratedFile(validatorFilename, file.GoImportPath)

		// Write the content without any package declaration or imports since it's already complete
		_, err = validatorFile.Write(content)
		if err != nil {
			return fmt.Errorf("failed to write validator file content: %v", err)
		}
	}

	// Now generate validation methods and add them to the protogen.GeneratedFile
	for _, message := range file.Messages {
		if hasValidationRules(message) {
			generateValidationMethod(g, message)
		}
	}

	return nil
}

func generateValidationMethod(g *protogen.GeneratedFile, msg *protogen.Message) {
	wrapperName := lowerFirst(msg.GoIdent.GoName) + "Wrapper"
	validateFuncName := "Validate" + wrapperName

	g.P("func (r *", msg.GoIdent, ") Validate() error {")
	g.P("return ", validateFuncName, "(&", wrapperName, "{")
	for _, field := range msg.Fields {
		g.P(field.GoName, ": r.Get", field.GoName, "(),")
	}
	g.P("})")
	g.P("}")
	g.P()
}

func copyFile(src, dst string) error {
	data, err := os.ReadFile(src)
	if err != nil {
		return err
	}
	return os.WriteFile(dst, data, 0644)
}

func fieldGoType(field *protogen.Field) string {
	if field.Desc.IsList() {
		return "[]" + fieldGoTypeForKind(field)
	}
	if field.Desc.IsMap() {
		keyType := fieldGoTypeForKind(field.Message.Fields[0])
		valueType := fieldGoTypeForKind(field.Message.Fields[1])
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}
	return fieldGoTypeForKind(field)
}

func fieldGoTypeForKind(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return field.Enum.GoIdent.GoName
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "any"
	default:
		return "any"
	}
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func checkGovalidInstalled() error {
	_, err := exec.LookPath("govalid")
	if err != nil {
		return fmt.Errorf("govalid is not installed or not in PATH: %v", err)
	}
	return nil
}

func runGovalid(packageDir string) error {
	// Change to package directory
	oldWd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %v", err)
	}

	if err := os.Chdir(packageDir); err != nil {
		return fmt.Errorf("failed to change to package directory %s: %v", packageDir, err)
	}
	defer os.Chdir(oldWd)

	// Run govalid . (current directory only)
	cmd := exec.Command("govalid", ".")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("govalid execution failed: %v", err)
	}

	return nil
}

func getOutputDirectory(gen *protogen.Plugin) string {
	// Not needed anymore since protogen handles file placement
	return "."
}

func hasValidationRules(msg *protogen.Message) bool {
	for _, field := range msg.Fields {
		if opts := getGovalidOptions(field); len(opts) > 0 {
			return true
		}
	}
	return false
}

func getGovalidOptions(field *protogen.Field) []string {
	// Get the govalid field options
	opts := field.Desc.Options()
	if opts == nil {
		return nil
	}

	// Extract govalid extension
	if proto.HasExtension(opts, govalid.E_Govalid) {
		ext := proto.GetExtension(opts, govalid.E_Govalid)
		if validation, ok := ext.(*govalid.FieldValidation); ok {
			return validation.Rules
		}
	}

	return nil
}
