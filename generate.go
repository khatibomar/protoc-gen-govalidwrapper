package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func generate(gen *protogen.Plugin, file *protogen.File) error {
	// Skip generating code for govalid.proto files
	if strings.Contains(file.Desc.Path(), "govalid.proto") {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_govalid.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-govalidwrapper. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()

	// Check if govalid is installed
	if err := checkGovalidInstalled(); err != nil {
		return err
	}

	// Get output directory from protoc parameters
	outputDir := getOutputDirectory(gen)

	// Pass 1: Generate wrapper structs only
	for _, message := range file.Messages {
		generateWrapperStruct(g, message)
	}

	// Pass 2: Write file, run govalid, then generate validation methods
	if err := generateValidationMethods(gen, file, g, outputDir, filename); err != nil {
		return err
	}

	return nil
}

func generateWrapperStruct(g *protogen.GeneratedFile, msg *protogen.Message) {
	wrapperName := lowerFirst(msg.GoIdent.GoName) + "Wrapper"

	// Generate wrapper struct
	g.P("type ", wrapperName, " struct {")

	// For each field, generate govalid comments + field
	for _, field := range msg.Fields {
		// Get govalid options from field
		if opts := getGovalidOptions(field); len(opts) > 0 {
			for _, rule := range opts {
				g.P("// +govalid:", rule)
			}
		}
		g.P(field.GoName, " ", fieldGoType(field))
	}
	g.P("}")
	g.P()
}

func generateValidationMethods(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, outputDir, filename string) error {
	// Write the file with wrapper structs to disk
	content, err := g.Content()
	if err != nil {
		return fmt.Errorf("failed to get file content: %v", err)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	// Write to actual file in output directory
	outputFile := outputDir + "/" + filename
	if err := os.WriteFile(outputFile, content, 0644); err != nil {
		return fmt.Errorf("failed to write file: %v", err)
	}

	// Run govalid to generate validation functions in output directory
	if err := runGovalid(outputDir); err != nil {
		return fmt.Errorf("govalid execution failed: %v", err)
	}

	// Read govalid-generated content and include it in our file
	if err := includeGovalidOutput(g, outputFile); err != nil {
		return fmt.Errorf("failed to include govalid output: %v", err)
	}

	// Generate validation methods
	for _, message := range file.Messages {
		generateValidationMethod(g, message)
	}

	return nil
}

func generateValidationMethod(g *protogen.GeneratedFile, msg *protogen.Message) {
	wrapperName := lowerFirst(msg.GoIdent.GoName) + "Wrapper"
	validateFuncName := "Validate" + lowerFirst(msg.GoIdent.GoName) + "Wrapper"

	g.P("func (r *", msg.GoIdent, ") Validate() error {")
	g.P("return ", validateFuncName, "(&", wrapperName, "{")
	for _, field := range msg.Fields {
		g.P(field.GoName, ": r.Get", field.GoName, "(),")
	}
	g.P("})")
	g.P("}")
	g.P()
}

func fieldGoType(field *protogen.Field) string {
	if field.Desc.IsList() {
		return "[]" + fieldGoTypeForKind(field)
	}
	if field.Desc.IsMap() {
		keyType := fieldGoTypeForKind(field.Message.Fields[0])
		valueType := fieldGoTypeForKind(field.Message.Fields[1])
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}
	return fieldGoTypeForKind(field)
}

func fieldGoTypeForKind(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return field.Enum.GoIdent.GoName
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		// We need to use the Go type of the message.
		// Using `any` for now as a placeholder for complex types
		// that might not be directly validatable by govalid on the wrapper.
		// A better implementation might return `*` + field.Message.GoIdent.GoName
		// but that could introduce import cycles if not handled carefully.
		return "any" // Or perhaps field.Message.GoIdent.GoName
	default:
		// Fallback for any other types.
		return "any"
	}
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func checkGovalidInstalled() error {
	_, err := exec.LookPath("govalid")
	if err != nil {
		return fmt.Errorf("govalid is not installed or not in PATH: %v", err)
	}
	return nil
}

func includeGovalidOutput(g *protogen.GeneratedFile, filename string) error {
	// Read the file that govalid modified/created
	content, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read govalid output: %v", err)
	}

	// Parse the content to extract only the validation functions
	// Look for functions that start with "Validate" and contain "Wrapper"
	lines := strings.Split(string(content), "\n")
	inValidationFunc := false
	braceCount := 0

	for _, line := range lines {
		// Check if this line starts a validation function
		if strings.Contains(line, "func Validate") && strings.Contains(line, "Wrapper") {
			inValidationFunc = true
			braceCount = 0
		}

		if inValidationFunc {
			// Count braces to know when function ends
			braceCount += strings.Count(line, "{")
			braceCount -= strings.Count(line, "}")

			// Add the line to our generated file
			g.P(line)

			// If we've closed all braces, the function is complete
			if braceCount == 0 && strings.Contains(line, "}") {
				inValidationFunc = false
				g.P() // Add empty line after function
			}
		}
	}

	return nil
}

func runGovalid(outputDir string) error {
	// Change to output directory
	oldWd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %v", err)
	}

	if err := os.Chdir(outputDir); err != nil {
		return fmt.Errorf("failed to change to output directory %s: %v", outputDir, err)
	}
	defer os.Chdir(oldWd)

	// Run govalid ./...
	cmd := exec.Command("govalid", "./...")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("govalid execution failed: %v", err)
	}

	return nil
}

func getOutputDirectory(gen *protogen.Plugin) string {
	// Default to current directory
	outputDir := "."

	// Try to get output directory from plugin parameters
	if gen.Request.Parameter != nil && *gen.Request.Parameter != "" {
		// Parameters are typically comma-separated
		params := strings.SplitSeq(*gen.Request.Parameter, ",")
		for param := range params {
			if after, ok := strings.CutPrefix(param, "output_dir="); ok {
				outputDir = after
				break
			}
		}
	}

	// If still default, try to infer from working directory structure
	if outputDir == "." {
		// Look for common output patterns like gen/go, generated, etc.
		if _, err := os.Stat("gen/go"); err == nil {
			outputDir = "gen/go"
		} else if _, err := os.Stat("generated"); err == nil {
			outputDir = "generated"
		}
	}

	return outputDir
}

func getGovalidOptions(field *protogen.Field) []string {
	// Get the govalid field options
	opts := field.Desc.Options()
	if opts == nil {
		return nil
	}

	// Extract govalid extension
	if proto.HasExtension(opts, E_Govalid) {
		ext := proto.GetExtension(opts, E_Govalid)
		if validation, ok := ext.(*FieldValidation); ok {
			return validation.Rules
		}
	}

	return nil
}
